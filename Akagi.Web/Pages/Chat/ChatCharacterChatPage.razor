@using Akagi.Web.Models.Chat
@using Akagi.Web.Pages.Chat.Components
@using Akagi.Web.Services.Sockets
@using Akagi.Web.Services.Sockets.Requests
@using Microsoft.AspNetCore.Components.Web
@using TabBlazor.Services
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.JSInterop

@inject ISocketClientContainer SocketClientContainer
@inject ToastService ToastService
@inject NavigationManager NavigationManager
@inject IJSRuntime JS
@inject ILogger<ChatCharacterChatPage> Logger

@implements IDisposable

@page "/Chat/{CharacterId}/"

<ChatConnectionStatus />

@if (_character == null)
{
	<p>Loading character...</p>
}
else
{
	<div class="chat-shell">
		<div class="chat-page">
			<div class="chat-scroll" @ref="_scrollEl">
				<div class="chat-thread">
					@foreach (Conversation conv in _conversations)
					{
						<div class="conversation-separator">
							<span>Conversation @conv.Id • @conv.Time.ToLocalTime().ToString("g") @(conv.IsCompleted ? "(completed)" : "")</span>
						</div>

						@foreach (Message baseMessage in conv.Messages)
						{
							if (baseMessage is not TextMessage textMessage)
							{
								continue;
							}

							bool fromUser = textMessage.From == Message.Type.User;
							string senderName = fromUser ? "You" : _character.Name;

							<div class="message-row @(fromUser ? "from-user" : "from-character")">
								@if (!fromUser)
								{
									<Avatar class="me-2 d-none d-sm-block"
											Rounded="AvatarRounded.Circle"
											Size="AvatarSize.Large"
											Data="@($"/socket/cards/{_character.CardId}/image.png?circuitId={SocketClientContainer.Client?.CircuitId}")" />
								}
								<div class="bubble">
									<div class="meta">
										<strong>@senderName</strong>
										<span class="time">@textMessage.Time.ToLocalTime().ToString("t")</span>
									</div>
									<div class="content">
										@foreach (string line in (textMessage.Text ?? string.Empty).Split(Environment.NewLine))
										{
											<span>@line</span>

											<br />
										}
									</div>
								</div>
							</div>
						}
					}
				</div>
			</div>

			<div class="composer" id="composer">
				<label class="form-label mb-1">Message</label>
				<InputTextArea class="form-control composer-input"
							   placeholder="Type a message. Enter = send, Shift+Enter = newline"
							   rows="3"
							   @bind-Value="_newMessage"
							   @onkeydown="OnMessageKeyDown" />

				<div class="mt-2 d-flex gap-2 align-items-center flex-wrap">
					<InputFile OnChange="OnFileSelected" />
					@if (_selectedFile is not null)
					{
						<span class="small text-muted">
							Attachment: @_selectedFile.Name (@(_selectedFile.Size / 1024) KB)
						</span>
						<Button BackgroundColor="TablerColor.Red" OnClick="ClearSelectedFile" Size="ButtonSize.Small">
							Remove
						</Button>
					}
				</div>

				<div class="mt-2 d-flex gap-2 align-items-center">
					<Button BackgroundColor="TablerColor.Green"
							OnClick="SendMessageAsync"
							Disabled="@(_isSending || (string.IsNullOrWhiteSpace(_newMessage) && _selectedFile is null))">
						Send
					</Button>
					@if (_isSending)
					{
						<span class="text-muted small">Sending...</span>
					}
					<span class="shortcut-hint text-muted ms-auto small d-none d-md-inline">
						Enter to send • Shift+Enter newline
					</span>
				</div>
			</div>
		</div>
	</div>
}

<style>
	/* Full viewport container ensures no outer page scroll is needed */
	.chat-shell {
		height: 100dvh;
		display: flex;
		flex-direction: column;
		/* Adjust if your main layout already adds padding/margins */
	}

	/* Flex column: scroll area + fixed-size composer */
	.chat-page {
		flex: 1;
		display: flex;
		flex-direction: column;
		overflow: hidden; /* Prevent page scroll */
		gap: .75rem;
		padding: .5rem .5rem .75rem;
		box-sizing: border-box;
	}

	/* The only scrollable area */
	.chat-scroll {
		flex: 1;
		min-height: 0;
		overflow-y: auto;
		padding: .75rem .75rem 1rem;
		border: 1px solid var(--tblr-border-color,#dee2e6);
		border-radius: .75rem;
		background: var(--tblr-body-bg,#fff);
		scroll-behavior: smooth;
	}

	.chat-thread {
		display: flex;
		flex-direction: column;
		gap: .6rem;
	}

	.conversation-separator {
		text-align: center;
		margin: 1.4rem 0 .9rem;
		position: relative;
		font-size: .65rem;
		text-transform: uppercase;
		letter-spacing: .05em;
		color: #6c757d;
		font-weight: 600;
	}

		.conversation-separator:before,
		.conversation-separator:after {
			content: "";
			position: absolute;
			top: 50%;
			width: 38%;
			height: 1px;
			background: #e5e7eb;
		}

		.conversation-separator:before {
			left: 0;
		}

		.conversation-separator:after {
			right: 0;
		}

	.message-row {
		display: flex;
		align-items: flex-end;
	}

		.message-row.from-user {
			justify-content: flex-end;
		}

	.bubble {
		max-width: 70ch;
		padding: .60rem .90rem .70rem;
		border-radius: 1.15rem;
		box-shadow: 0 1px 2px rgba(0,0,0,.08);
		position: relative;
		display: flex;
		flex-direction: column;
		gap: .30rem;
		font-size: .92rem;
		line-height: 1.28rem;
		white-space: pre-wrap;
		word-break: break-word;
	}

	.message-row.from-character .bubble {
		background: #f1f3f5;
		color: #212529;
		border-bottom-left-radius: .40rem;
	}

	.message-row.from-user .bubble {
		background: var(--tblr-primary,#4c6ef5);
		color: #fff;
		border-bottom-right-radius: .40rem;
	}

	.bubble .meta {
		font-size: .60rem;
		opacity: .75;
		display: flex;
		align-items: center;
		gap: .4rem;
		margin-bottom: .05rem;
		font-weight: 500;
	}

	.message-row.from-user .bubble .meta {
		color: rgba(255,255,255,.85);
	}

	.message-row.from-character .bubble:after,
	.message-row.from-user .bubble:after {
		content: "";
		position: absolute;
		bottom: 0;
		width: 12px;
		height: 12px;
		background: inherit;
	}

	.message-row.from-character .bubble:after {
		left: -4px;
		clip-path: polygon(0 100%, 0 0, 100% 100%);
	}

	.message-row.from-user .bubble:after {
		right: -4px;
		clip-path: polygon(0 100%, 100% 0, 100% 100%);
	}

	/* Composer always visible (no sticky/fixed needed since container doesn't scroll) */
	.composer {
		border: 1px solid var(--tblr-border-color,#dee2e6);
		border-radius: .75rem;
		padding: .9rem .9rem 1rem;
		background: var(--tblr-body-bg,#fff);
		box-shadow: 0 2px 4px -2px rgba(0,0,0,.05);
	}

	.composer-input {
		resize: vertical;
		min-height: 90px;
		max-height: 35vh;
	}

	.shortcut-hint {
		opacity: .65;
	}

	/* Mobile adjustments */
	@@media (max-width: 576px) {
		.bubble {
			max-width: 85%;
		}

		.chat-page {
			gap: .5rem;
			padding: .5rem;
		}

		.chat-scroll {
			padding: .6rem .6rem .9rem;
		}

		.composer {
			padding: .75rem .75rem .85rem;
		}

		.composer-input {
			min-height: 70px;
		}
	}

	/* Short viewports */
	@@media (max-height: 540px) {
		.composer-input {
			min-height: 60px;
			max-height: 28vh;
		}
	}
</style>

@code {
	[Parameter]
	public required string CharacterId { get; set; } = string.Empty;

	private Character? _character = null;
	private Conversation[] _conversations = [];

	private string _newMessage = string.Empty;
	private bool _isSending = false;
	private bool registeredForMessages = false;

	private IBrowserFile? _selectedFile = null;
	private const long MaxUploadBytes = 50 * 1024 * 1024; // 50 MB

	// Auto-scroll support
	private ElementReference _scrollEl;
	private IJSObjectReference? _jsModule;
	private bool _pendingScroll;

	public void Dispose()
	{
		SocketClient? client = SocketClientContainer.Client;
		if (client == null)
		{
			return;
		}

		client.MessageRecieved -= OnClientMessageReceived;
	}

	protected override async Task OnInitializedAsync()
	{
		SocketClient? client = SocketClientContainer.Client;
		if (client == null)
		{
			return;
		}
		if (!registeredForMessages)
		{
			client.MessageRecieved += OnClientMessageReceived;
			registeredForMessages = true;
		}

		if (string.IsNullOrWhiteSpace(CharacterId))
		{
			throw new ArgumentException("CharacterId cannot be null or empty.", nameof(CharacterId));
		}

		if (string.Equals(CharacterId, "0", StringComparison.OrdinalIgnoreCase))
		{
			return;
		}

		CharacterListRequest request = new CharacterListRequest
		{
			Ids = [CharacterId]
		};
		Character[] characters = await request.Get(client);
		if (characters.Length == 0 || characters[0] == null || characters[0].Id != CharacterId)
		{
			throw new InvalidOperationException($"Character with ID '{CharacterId}' not found.");
		}

		_character = characters[0];

		await RefreshAllMessages();
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			_jsModule = await JS.InvokeAsync<IJSObjectReference>("import", "./Pages/Chat/ChatCharacterChatPage.razor.js");
			_pendingScroll = true;
		}

		if (_pendingScroll)
		{
			_pendingScroll = false;
			if (_jsModule != null)
			{
				try
				{
					await _jsModule.InvokeVoidAsync("scrollToBottom", _scrollEl);
				}
				catch
				{
					// ignore JS errors
				}
			}
		}
	}

	private async Task RefreshAllMessages()
	{
		SocketClient? client = SocketClientContainer.Client;
		if (client == null)
		{
			return;
		}

		ConversationRequest request = new ConversationRequest
		{
			CharacterId = CharacterId,
		};
		_conversations = await request.Get(client);
		_pendingScroll = true;
		StateHasChanged();
	}

	private async Task SendMessageAsync()
	{
		if (_isSending || string.IsNullOrWhiteSpace(_newMessage))
		{
			return;
		}

		SocketClient? client = SocketClientContainer.Client;
		if (client == null)
		{
			return;
		}

		string messageToSend = _newMessage?.Trim() ?? string.Empty;

		_isSending = true;
		_newMessage = string.Empty;
		StateHasChanged();

		try
		{
			if (_selectedFile is not null)
			{
				FileTemp? file = await GetFileContent(_selectedFile);
				if (file == null)
				{
					await ToastService.AddToastAsync(new ToastModel
					{
						Title = "Upload failed",
						Message = "Could not upload the selected file."
					});
					return;
				}

				await SendFile(client, messageToSend, file);
			}
			else
			{
				await SendText(client, messageToSend);
			}
		}
		finally
		{
			_selectedFile = null;
			_isSending = false;
			StateHasChanged();
		}
	}

	private class FileTemp
	{
		public required string Name { get; init; }
		public required string Type { get; init; }
		public required byte[] Data { get; init; }
	}

	private async Task<FileTemp?> GetFileContent(IBrowserFile file)
	{
		try
		{
			using StreamContent fileContent = new(file.OpenReadStream(MaxUploadBytes));
			byte[] bytes = await fileContent.ReadAsByteArrayAsync();
			return new FileTemp
			{
				Name = file.Name,
				Type = file.ContentType,
				Data = bytes
			};
		}
		catch
		{
			return null;
		}
	}

	private async Task SendText(SocketClient client, string messageToSend)
	{
		try
		{
			SendTextMessageRequest request = new SendTextMessageRequest
			{
				CharacterId = CharacterId,
				Text = messageToSend,
			};

			TextMessageResult result = await request.Get(client);
			if (!string.IsNullOrEmpty(result.Error))
			{
				await ToastService.AddToastAsync(new ToastModel
				{
					Title = "Message Response",
					Message = $"Error from character: {result.Error}"
				});
				return;
			}
			Conversation? conv = _conversations.MaxBy(x => x.Time);
			if (conv == null)
			{
				await ToastService.AddToastAsync(new ToastModel
				{
					Title = "Message Response",
					Message = "No active conversation found. Please refresh the page and try again."
				});
				return;
			}
			conv.Messages.Add(new TextMessage
			{
				From = Message.Type.User,
				Text = messageToSend,
				Time = DateTime.UtcNow,
			});
			_pendingScroll = true;
		}
		catch (Exception)
		{
			await ToastService.AddToastAsync(new ToastModel
			{
				Title = "Message Response",
				Message = "Failed to get a response from the character. Please try again."
			});
		}
	}

	private async Task SendFile(SocketClient client, string messageToSend, FileTemp fileToSend)
	{
		try
		{
			SendFileMessageRequest request = new SendFileMessageRequest
			{
				CharacterId = CharacterId,
				Text = messageToSend,
				FileName = fileToSend.Name,
				FileType = fileToSend.Type,
				FileData = fileToSend.Data,
			};

			FileMessageResult result = await request.Get(client);
			if (!string.IsNullOrEmpty(result.Error))
			{
				await ToastService.AddToastAsync(new ToastModel
				{
					Title = "Message Response",
					Message = $"Error from character: {result.Error}"
				});
				return;
			}
			Conversation? conv = _conversations.MaxBy(x => x.Time);
			if (conv == null)
			{
				await ToastService.AddToastAsync(new ToastModel
				{
					Title = "Message Response",
					Message = "No active conversation found. Please refresh the page and try again."
				});
				return;
			}
			conv.Messages.Add(new TextMessage
			{
				From = Message.Type.User,
				Text = messageToSend,
				Time = DateTime.UtcNow,
			});
			_pendingScroll = true;

		}
		catch (Exception)
		{
			await ToastService.AddToastAsync(new ToastModel
			{
				Title = "Message Response",
				Message = "Failed to get a response from the character. Please try again."
			});
		}
	}

	private async Task OnMessageKeyDown(KeyboardEventArgs e)
	{
		if (e.Key == "Enter" && !e.ShiftKey)
		{
			await SendMessageAsync();
		}
	}

	private void OnClientMessageReceived(string? characterId, Message message)
	{
		_conversations.MaxBy(x => x.Time)?.Messages.Add(message);
		_pendingScroll = true;
		InvokeAsync(StateHasChanged);
	}

	private void OnFileSelected(InputFileChangeEventArgs e)
	{
		_selectedFile = e.File;
		StateHasChanged();
	}

	private void ClearSelectedFile()
	{
		_selectedFile = null;
		StateHasChanged();
	}
}
